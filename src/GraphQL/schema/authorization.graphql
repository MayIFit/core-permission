"Represents NULL values"
scalar VoidScalar @scalar(class: "MayIFit\\Core\\Permission\\GraphQL\\Scalars\\VoidScalar")

extend type Query @guard(with: ["sanctum"]) {
    me: User @auth

    allUser: [UserSelect]! @all

    listUser(
        filter: _ @whereConditions(columnsEnum: "UserWhereColumn")
    ): [User!]! 
        @can(ability: "viewAny" model: "User") 
        @paginate(type: "paginator")

    viewUser(
        id: ID @eq
    ): User! 
        @can(ability: "view" find:"id") @find

    hasPermission(entity: String! permission: String!): Boolean! 
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Queries\\HasPermission@resolve")
}

extend type Mutation {
    registerUser(
        input: RegisterUserInput! @spread
    ): User 
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\UserRegistration@resolve")

    loginUser(
        input: LoginUserInput! @spread
    ): User 
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\UserAuthentication@login")

    resetUserPassword(
        input: ResetUserPasswordInput! @spread
    ): User
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\UserPasswordReset@resolve")
    
    sendUserPasswordResetNotification(
        input: ResetUserPasswordNotificationInput! @spread
    ): VoidScalar @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\UserPasswordReset@sendEmailNotification")
}

extend type Mutation @guard(with: ["sanctum"]) {
    createUser(
        input: CreateUserInput @spread
    ): User 
        @can(ability: "create" model: "User") 
        @create

    updateUser(
        input: UpdateUserInput @spread
    ): User 
        @can(ability: "update" find: "id") 
        @update

    deleteUser(
        id: ID! @rules(apply: ["required"])
    ): User 
        @can(ability: "delete" find: "id") 
        @delete

    logoutUser: Boolean
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\UserAuthentication@logout")

    impersonateUser(
        id: ID!
    ): User 
        @field(resolver: "MayIFit\\Core\\Permission\\GraphQL\\Mutations\\ImpersonateUser@impersonate")
}

input ResetUserPasswordNotificationInput {
    email: String! @trim @rules(apply: ["required", "email", "exists:users,email"])
}

input LoginUserInput {
    email: String! @trim @rules(apply: ["required", "email", "exists:users,email"])
    password: String! @trim @rules(apply: ["required"])
}

input RegisterUserInput {
    email: String! @trim @rules(apply: ["required", "email", "unique:users,email"])
    password: String! @trim @rules(apply: ["required", "min:8"]) @hash
}

input ResetUserPasswordInput {
    email: String! @trim @rules(apply: ["required", "email", "exists:users,email"])
    token: String! @trim @rules(apply: ["required"])
    password: String! @trim @rules(apply: ["required", "min:8"]) @hash
}

input UpdateUserInput {
    id: ID!
    name: String
    real_name: String
    email: String
    password: String @hash
    permissions: PermissionRelation
    roles: RoleRelation
    language: String
    approved: Boolean
    image: UpdateDocumentHasOne
}

input CreateUserInput {
    name: String!
    real_name: String
    email: String!
    password: String! @hash
    permissions: PermissionRelation
    roles: RoleRelation
    language: String!
}

input UserRelation {
    connect: ID
}

type User {
    id: ID!
    name: String
    real_name: String
    email: String!
    image: Document
    "ISO 639-1"
    language: String
    "Accessible only for login"
    access_token: String
}

extend type User @guard(with: ["sanctum"]) {
    created_at: DateTime!
    updated_at: DateTime!
    roles: [Role!] @belongsToMany
    permissions: [Permission!] @belongsToMany
    approved: Boolean
}

"Subset of User"
type UserSelect @guard(with: ["sanctum"]) @modelClass(class: "User") {
    id: ID!
    email: String!
}

"A list of filterable columns."
enum UserWhereColumn {
    REAL_NAME @enum(value: "real_name")
    NAME @enum(value: "name")
    EMAIL @enum(value: "email")
}